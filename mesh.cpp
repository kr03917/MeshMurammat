#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Surface_mesh.h>
#include <CGAL/Advancing_front_surface_reconstruction.h>
#include <CGAL/Polygon_mesh_processing/triangulate_faces.h>
#include <CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h>
#include <CGAL/boost/graph/helpers.h>
#include <CGAL/boost/graph/IO/PLY.h>
#include <fstream>
#include <iostream>
#include <vector> 
//#include "pointcloud.h"
#include "polygonalMesh.h"
#include "mesh_hole.h"
//typedef CGAL::Exact_predicates_inexact_constructions_kernel Kernel;
//typedef Kernel::Point_3                                     Point;
//typedef CGAL::Surface_mesh<Point>                           Surface_mesh;
//typedef boost::graph_traits<Surface_mesh>::face_descriptor        face_descriptor;
//typedef boost::graph_traits<Surface_mesh>::vertex_descriptor      vertex_descriptor;
namespace PMP = CGAL::Polygon_mesh_processing;

int main(int argc, char* argv[])
{
    //const char* filename = (argc > 1) ? argv[1] : "bowl_1_1.ply"; //remain in main
    const char* filename = (argc > 1) ? argv[1] : "polygoninput.ply"; //remain in main
    //MeshType inputMeshFile;
    //PolygonMesh polyMesh;
    //polyMesh.read_input(filename);
    //polyMesh.mesh.number_of_vertices();
    //polyMesh.triangulateSurface();

    //Surface_mesh input_mesh;
    /*Surface_mesh output_mesh;
    if (!CGAL::read_PLY(filename, mesh))
    {
        std::cerr << "Invalid input." << std::endl;
        
        return 1;
    }*/

    //Mesh mesh_ply;
    //read_PLY(filename, mesh_ply);
    //filename.close();

    MeshType inputMeshFile;
    inputMeshFile.checkType(filename);
    std::string typeOfMesh = inputMeshFile.get_type();
    /*PointCloud pointMesh;
    if (typeOfMesh == "point cloud") {
         pointMesh.read_input(filename);
         pointMesh.removeOutliers();
         pointMesh.simplifyPointset();
         pointMesh.reconstructSurface();   
         pointMesh.convertToSoup();
         pointMesh.write_output();
    }*/
    PolygonMesh polyMesh;
    if (typeOfMesh == "polygon") {
        polyMesh.read_input(filename);
        polyMesh.triangulateSurface();
        polyMesh.addingFacesVertices();
        polyMesh.write_output_poly();
    }
    
    //Mesh_holes a;
    //a.set_mesh(pointMesh.getMesh());
    ////Mesh output_mesh = a.generate_hole_highlight();
    ////std::vector<Hole> hole_list = a.get_hole_list();
    //a.holefill_benchmark();
    //Mesh output_mesh = a.get_mesh();
    ////faces not getting merged with mesh...
    ////std::cout << output_mesh.number_of_faces() << std::endl;
    ////std::cout << output_mesh.number_of_vertices() << std::endl;
    //a.~Mesh_holes();
    //std::ofstream output("pointcloudOutput.ply");
    //CGAL::write_PLY(output, output_mesh);
    //
    // MeshType inputMeshFile;
    // inputMeshFile.checkType(filename);
    // std::string typeOfMesh = inputMeshFile.get_type();
    // if (typeOfMesh == "point cloud") {
    //     PointCloud pointMesh;
    //     pointMesh.read_input(filename);
    //     pointMesh.reconstructSurface();
    // }

    //typedef std::array<std::size_t, 3> Facet; // Triple of indices
    //std::vector<Facet> facets;
    ////The function is called using directly the points raw iterators
    //CGAL::advancing_front_surface_reconstruction(pointMesh.mesh.points().begin(), mesh.points().end(), std::back_inserter(facets));
    //std::cout << facets.size() << " facet(s) generated by reconstruction." << std::endl;
    //std::vector<Point> vertices;
    //vertices.reserve(mesh.vertices().size());
    //std::copy(mesh.points().begin(), mesh.points().end(), std::back_inserter(vertices));
    //CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh(vertices, facets, output_mesh);
    
    
    return 0;
}
