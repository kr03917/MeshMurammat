#include <iostream>
#include "pointcloud.h"
#include <fstream>
PointCloud::PointCloud(){

}

void PointCloud::read_input(const char* filename){

    std::ifstream stream(filename, std::ios_base::binary);
    if (!stream)
    {
        std::cerr << "Error: cannot read file " << filename << std::endl;
    }
    stream >> points;
}

void PointCloud::removeOutliers() {
    CGAL::remove_outliers<CGAL::Sequential_tag>(points,24,points.parameters().threshold_percent(5.0));
    points.collect_garbage();
}

void PointCloud::simplifyPointset() {
    double spacing = CGAL::compute_average_spacing<CGAL::Sequential_tag>(points, 6);
    CGAL::grid_simplify_point_set(points, 2. * spacing);
    points.collect_garbage();
    CGAL::jet_smooth_point_set<CGAL::Sequential_tag>(points, 24);
}

void PointCloud::reconstructSurface() {
    CGAL::advancing_front_surface_reconstruction(points.points().begin(),points.points().end(), std::back_inserter(facets));
    std::cout << facets.size()<< " facet(s) generated by reconstruction." << std::endl;
}
void PointCloud::convertToSoup() {
    vertices.reserve(points.size());
    std::copy(points.points().begin(), points.points().end(), std::back_inserter(vertices));
     CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh(vertices, facets, mesh);
}

void PointCloud::write_output(){
    std::ofstream output("pointcloudClassOutput.ply");
    CGAL::write_PLY(output, mesh);
}

Surface_mesh PointCloud::getMesh() {
    return mesh;
}